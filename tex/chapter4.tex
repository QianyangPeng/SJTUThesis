%# -*- coding: utf-8-unix -*-
%%==================================================
%% chapter01.tex for SJTU Master Thesis
%%==================================================

%\bibliographystyle{sjtu2}%[此处用于每章都生产参考文献]
\chapter{搜索后台与前端的接口设计}
\label{chap:c4}

在实现了搜索引擎的后台之后，接下来的步骤就是将其上线到网站上，并实现相应的用户交互接口与界面。这一部分的功能在网站代码的php文件中实现。其实现流程图如下：

\begin{figure}[!htp]
    \centering
    \resizebox{5.5cm}{!}{\input{figure/page_stru.tex}}
    \bicaption[fig:website]{网页处理流程图}{网页处理流程图}{Fig}{Website Handler Procedure}
\end{figure}

当用户输入被确认合法（即去除特殊符号与停用词后不为空字符串）后，用户输入被封装到传入solr服务器的html请求的query字段中，并访问Solr服务器以寻求其答复。发送给Solr的HTTP请求基本格式如下：

http://***.***.***.***:****/solr/collection/select?indent=on\&q=content\&wt=json\&page=2\\
\&sort=PaperPublishYear desc\&facet=false

事实上，我们还可以对solr服务器提出更多的要求，例如利用edismax改变打分规则等。由于在本课题中没有得到应用，故略去不讲。在上面那个例子中，HTTP请求声明的参数如下：

\begin{itemize}
\item q: 请求内容的主体，即用户搜索的内容。如果请求内容包含多个单词，用空格隔开的话，多个关键词之间是或的关系，服务器会返回所有含有任何一个关键词的结果。如果在每个关键词前面添加一个'+'符号，多个关键词之间即是与的关系，服务器只会返回包含有全部关键词的结果。另外，如果不指定搜索的范围，默认会在\_entext\_域进行搜索（见第二章，平台配置）；如果指定搜索的范围，会在指定的某个域中进行搜索。
\item wt: 返回结果的格式。此处指定为json，也可以根据需要改成python, xml, php等。这一部分不影响返回的内容，但是会影响返回内容的组织格式，在网页对返回结果进行解析的时候，需要选择与此处格式配套的解析策略。
\item page: 翻页情况。被索引的论文总数超过一亿篇，这意味着一般搜索一个关键词都会看到超过一万条的返回结果，而返回全部的搜索结果是不现实的。这时候就需要进行翻页。在默认情况下，每页返回十条记录，通过指定该参数，可以让服务器返回结果中的第10*(page-1)+1到第10*page条结果。
\item sort：结果排序情况。默认条件下，我们设置将结果按照论文的引用数排序，如果需要按其他的字段，如按出版年份降序排序，就可以按上例所示修改排序方式。可以同时指定多个排序方式，用逗号隔开，即当前一个指定项相同时，按后一个指定项的顺序进一步排列结果。
\item facet：是否统计结果。Solr服务器提供了统计结果的功能，本搜索平台也在网页上对结果统计进行了相关的界面实现。但是统计结果功能会在一定程度上影响响应速度，所以当对返回结果速度要求较高的时候，可以将此参数设为否，即关闭统计功能。
\end{itemize}

如果Solr服务器正确响应，对于以上请求将会以Http Response的形式返回一个.json格式的文件。该文件中即包含了网页需要显示的所有信息。该文件的结构如下：

\begin{lstlisting}[caption={返回文件格式}, label=returnfileformat, escapeinside="", numbers=none]
{
  "responseHeader":{
    "status":0,
    "QTime":1442,
    "params":{
      "q":"content",
      "indent":"on",
      "page":"2",
      "wt":"json",
      "facet":"false"}},
  "response":{"numFound":332899,"start":0,"docs":[
      {
        "PaperReferenceCount":0,
        "ConferenceShortName":"",
        "\_entext\_":["",
          "",
          "contents contents",
          "Contents-May 2015",
          "2015"],
        "AuthorID":["7AABEB29"],
        "OriginalVenueName":[""],
        "AuthorName":["contents contents"],
        "ConferenceSeriesID":"",
        "OriginalPaperTitle":["Contents-May 2015"],
        "JournalID":"",
        "AuthorSequenceOrder":[1],
        "PaperPublishYear":2015,
        "id":"5F993E0C",
        "\_version\_":1554052763125547020},
    ......],
     "highlighting":{
    "5F993E0C":{
      "OriginalPaperTitle":["<font color=\#196600>Contents</font>-May 2015"]},
    ......
     }}}
\end{lstlisting}

在该响应文件中，responseheader里显示了我们查询的参数，response中显示了响应的内容。其中，response中的docs列表中将会返回在该次查询中返回的十条结果，我们只要解析该json文件，并把对应字段的内容加上对应字体的html标签在返回页面显示，就实现了搜索结果的展示功能。除了基本内容之外，网页还有结果高亮和结果统计两个扩展功能，这些功能进一步扩展了网页的显示效果。
\section{结果高亮}
结果高亮的目的是用不同的颜色或字体表现用户搜索的关键词部分，使之更加明显。在系统构建的过程中，最初关键词高亮的功能是通过正则表达式匹配替换的方法实现的，即在返回结果中正则匹配出用户输入关键词的部分，然后用两边加入不同颜色的HTML标签的方式实现。然而正则表达式匹配法在高亮上存在一个两难抉择的问题：

\begin{itemize}
\item 如果采用宽松的匹配方式，即只匹配搜索关键词而不管关键词两边的内容，可能会出现错误匹配的情况。例如，用户搜索单词get的时候，和关键词无关但是包含了该单词的单词会被全部高亮，例如together, forget等，但是因为本搜索平台是以词为单位进行检索，因而这些结果并不是因为被高亮的部分而被查询到的，这样一来，这种高亮显示就会对用户产生误导，也偏离了关键词高亮这一功能的设计初衷。
\item 如果采取严格的匹配方式，即匹配搜索关键词，而且要求关键词两端是字符串边界，空白字符或符号的话，可以避免上述的问题，但是名词或动词变形的情况就无法被匹配到。例如动词结尾+s, +es, +ed，或以y结尾的动词的过去式变形等。这样一来高亮的功能就会受到一些限制，同样会影响到高亮功能的表现。
\end{itemize}

考虑到以上两个问题用正则匹配法难以同时解决，搜索平台不得不采取另一种方法解决关键词高亮的问题。平台采用的方法为词根匹配并记录位置的方法，由于在搜索引擎中，系统对用户请求和文档内容本身都进行了词根化的操作，而词根也是搜索引擎进行检索的最小单位，因此我们只要记录词根在文档中出现的位置，再于词根化之前的文本中的相同位置进行高亮标记，即可实现同时解决了上述两个问题的高亮算法。在上面的示例文件中可见，虽然用户的查询内容是content，但是首字母大写的复数形式Contents也被正确高亮，同时，由于包含了content的其它单词，例如subcontent，和content拥有不同的词根，因此不会被高亮标记。

在json返回结果中，我们将highlighting域的对应内容，代替docs域的对应内容放在网页上进行展示，即可达到关键词被高亮显示的效果。

\section{结果统计}
结果统计功能的目的是统计搜索结果的分布情况。本论文第二章中已经提到过，配置文件中对搜索平台搜索结果的默认统计域有五个——出版年份，关键词，作者，会议名称，期刊名称。其中对于每篇文章，会议名称和期刊名称不会同时出现。统计功能即是统计搜索结果中出版于各个年份的论文数目是多少，拥有某关键词的论文数目是多少，还有不同作者与搜索关键词相关的论文数量数目等等。结果统计功能可以让用户不需要浏览所有的搜索结果，就可以对搜索结果的特点产生直观的印象。

如果在html请求中将facet=false改为facet=true，即可打开结果统计功能。此时，服务器返回的json文件中会增加一个facet键对应的内容：

\begin{lstlisting}[caption={结果统计}, label=facet, escapeinside="", numbers=none]
{
"facet\_counts":{
    "facet\_queries":{},
    "facet\_fields":{
      "PaperPublishYear":[
        "2013",23649,
        "2014",22127,
        "2012",20761,
        .....],
      "KeywordID":[
        "017C8A77",9940,
        "08EE83EF",5945,
        "09AEBB9C",4648,
        "200524E7",4165,
        .....],
      .....},
    "facet\_ranges":{},
    "facet\_intervals":{},
    "facet\_heatmaps":{}}
}
\end{lstlisting}

如上例所示，由于统计功能的相关参数都在默认配置文件中指定，因此facet\_queries等域的内容均为空。同时，facet\_fields的内容显示了与该关键词相关的论文的分布情况，例如出版于2013年的论文的数量为23649篇，2014年的数量为22127篇等。

得到了该统计结果，接下来就是要在网页上对其进行可视化显示。在平台中，我们使用了ACharts.js\citen{achart}作为绘图工具绘制统计结果图表。考虑到在这五个被统计的域中，对于年份人们关心的是数量随时间变化的信息，而对于其他四个域人们关心的是数量排名信息，因此我们对年份域的结果按年份排序，对其他域的统计结果按统计数目从多到少排序，再分别用折线图，柱状图或饼状图进行分别呈现。

由于结果统计功能复杂度较高，花费时间多，因此开启了统计结果的网页响应速度会比关闭该功能的响应速度慢500毫秒左右。为了解决这一问题，平台采用了Ajax异步加载的方法，让搜索结果和统计结果异步完成呈现。在用户提交查询请求后，平台会先向搜索服务器发送一次关闭统计功能的请求，先快速显示查询结果，此时统计结果的图表显示为加载状态。查询结果显示完毕后，平台再向服务器发送一次打开结果统计的请求，得到响应后再绘制结果统计的各项图表。